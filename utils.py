from langchain_community.utilities import SQLDatabase
from langchain_core.prompts import PromptTemplate
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_experimental.sql.base import SQLDatabaseChain
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_community.utilities import SQLDatabase
from langchain.chains import LLMChain
from langchain.memory import ConversationBufferMemory
import configparser
import os
import retrying

def read_properties_file(file_path):
    # Check if the file exists
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"The file '{file_path}' does not exist.")
    # Initialize the configparser
    config = configparser.ConfigParser()
    # Read the properties file
    config.read(file_path)
    # Access values
    db_path = config['DEFAULT']['db_path']
    gemini_api_key = config['DEFAULT']['gemini_api_key']  
    return db_path, gemini_api_key

def get_property():
    # Path to the properties file
    file_path = 'config.properties'
    try:
        db_path, gemini_api_key = read_properties_file(file_path)
        #print("Database path:", db_path)
        #print("Gemini API Key", gemini_api_key)
        return db_path, gemini_api_key
    except FileNotFoundError as e:
        print(e)
        raise e
    
def get_llm(gemini_api_key):
    """
    Creata an instance of Google Gemini Pro
    returns:
    - llm: An instance of Google Gemini Pro
    """
    # Create llm
    llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash-latest", google_api_key=gemini_api_key, 
                                 convert_system_message_to_human=False, temperature=0.7)
    return llm

def db_connection(db_path):
    db = SQLDatabase.from_uri(f"sqlite:///{db_path}",include_tables=['Act_bcmp', 'Act_fdp', 'Act_md', 'Act_mt', 'Act_pc', 'Act_pgd', 'Act_pr' ,'Act_pt' ,'Act_re' ,'Act_ws'],sample_rows_in_table_info=138)
    #print(db.dialect)
    #print(db.get_usable_table_names())
    resp = db.run("SELECT * FROM Act_bcmp LIMIT 3;")
   # print(resp)
    return db

def create_conversational_chain():
    try:
        db, gemini_api_key = get_property()
        # Get the instance of LLM
        llm = get_llm(gemini_api_key)
        # Get the DB connection
        db = db_connection(db)
        sql_prompt_template = """
		You are an AI assistant designed to assist users in retrieving information from a database consist of 14 tables. By converting their 	questions into SQL queries strictly should not including these (```sql) in start and (```) and also a newline(\n) in end in sql query and after that execute the proper query generated by the model to get perfect answers. Those tables are not linked so for every questions generate queries for all tables.
	Sample questions
	Example 1 Question: who is chief investigator of IIITDM Kurnool
	Query :SELECT "Chief_Investigator" FROM Act_bcmp WHERE "Institute" = 'IIITDM Kurnool' UNION SELECT "Chief_Investigator" FROM Act_fdp WHERE "Institute" = 'IIITDM Kurnool' UNION SELECT "Chief_Investigator" FROM Act_md WHERE "Institute" = 'IIITDM Kurnool' UNION SELECT "Chief_Investigator" FROM Act_mt WHERE "Institute" = 'IIITDM Kurnool' UNION SELECT "Chief_Investigator" FROM Act_pc WHERE "Institute" = 'IIITDM Kurnool' UNION SELECT "Chief_Investigator" FROM Act_pgd WHERE "Institute" = 'IIITDM Kurnool' UNION SELECT "Chief_Investigator" FROM Act_pr WHERE "Institute" = 'IIITDM Kurnool' UNION SELECT "Chief_Investigator" FROM Act_pt WHERE "Institute" = 'IIITDM Kurnool' UNION SELECT "Chief_Investigator" FROM Act_re WHERE "Institute" = 'IIITDM Kurnool' UNION SELECT "Chief_Investigator" FROM Act_ws WHERE "Institute" = 'IIITDM Kurnool'
	Same for all the questions replace the institute name only and give distinct results

	1. Receive the user's input question.
	2. Translate the question into a valid SQL query. Ensure the SQL query doesn't contain special characters like backticks (``` and ```sql) or newline characters (`\n`).
	3. Execute the valid sql query against the database.
	4. Return the results to the user.
	You have access to the following 14 tables. Please carefully consider each column and row in these tables:{table_info}
	User Question:{input}
	Given an input question, create a syntactically correct {dialect} query to execute.
	Relevant pieces of previous conversation:{history}
	(You do not need to use this information if it's not relevant.)
	Please ensure that the generated SQL query strictly adheres to the guidelines mentioned above.
"""


        prompt = PromptTemplate(
            input_variables=["input", "table_info", "dialect", "history"],
            template=sql_prompt_template
        )
        memory = ConversationBufferMemory(memory_key="history")
        db_chain = SQLDatabaseChain.from_llm(
            llm, db, memory=memory, prompt=prompt, return_direct=True, verbose=True
        )
        output_parser = StrOutputParser()
        chain = llm | output_parser
    except Exception as e:
        raise e
    return db_chain, chain

